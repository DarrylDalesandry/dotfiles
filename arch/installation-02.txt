Part 2: Chrooting into the new system
========================================

At this point of an Arch installation:
- Drives should have partitions created
- Each partition should have a file system setup on them
- The home partition and /efi partition should be mounted
- Linux packages and firmware should be installed on the main drive



From: https://wiki.archlinux.org/title/Installation_guide

Next up, is then to remotely connect to the linux system from Arch's live
 environment.

------------------------------
# arch-chroot /mnt
------------------------------

The command "arch-chroot" allows the tty shell being run from the Arch ISO, to
 connect to the drive with the Arch packages recently installed, and run
  commands as if the non-booted Arch systems were booted into and connected

The Arch packages on the drive will not allow booting into Arch directly, so
 using "arch-chroot" is needed at this time. If the system reboots, and the
  Arch ISO needs to be loaded again, then the LUKS partition needs unlocked,
   partitions need mounted, and "arch-chroot" needs run again.




The local time needs set first. This is done by creating a symbolic link from
 a binary file in one folder, and have that link point to another file.

I live in the Eatern Time Zone in the United States. So my regional information
 is at: "/usr/share/zoneinfo/America/New_York"

This is a binary blob. The symbolic link to show current time instead of UTC
 time is:

------------------------------
# ln -sf /usr/share/zoneinfo/America/New_York /etc/localtime
# hwclock --systohc
------------------------------

This will set the New_York time zone to the localtime file, and saves
 information of the hardware clock and drift time. The second command saves
  this info to "/etc/adjtime".


Next, is to make sure the system is setup to correct any drifting time from
 the system, and the world's time. Of the options available, the one that I
  prefer to use is the Network Time Protocol daemon.

The "ntp" package should have been installed already from the "pacstrap" command
 in the previous file. If it is not installed then it can be by runing:

------------------------------
# pacman -S ntp
------------------------------

Then, check the ntp file for four server addresses for network time.

------------------------------
# cat /et/ntp.conf
------------------------------




Localization now needs setup. This is to make sure that date, time, currency,
 and number system formats work correctly for the region that the system is
  running in.

First, edit the file "/etc/locale.gen" by uncommenting the UTF-8 locale that
 is desired.

For me, the desired locale to uncomment is: en_US.UTF-8

 Then, generate the locales by running:

------------------------------
# locale-gen
------------------------------

Create the file /etc/local.conf, and add the line:
LANG=en_US.UTF-8

Last, make the keyboard console layout persistent by creating the file
 "etc/vconsole.conf", and adding the line:
KEYMAP=us




The /efi partition now needs hardened. This is to prevent the boot partition
 from being globally accessible, allowing it to mount when needed, and
  unmount after 10 minutes of inativity.

Look up the UUID of the /efi partition (found with the command "lsblk -f". This
 UUID will be only a few characters long, it won't be a long string.

Then run:

------------------------------
# nvim /etc/fstab
------------------------------

While editing "fstab" add the line:

------------------------------
UUID={Add UUID Here} /efi vfat defaults,noatime,uid=0,gid=0,umask=0077,
  x-systemd.automount,x-systemd.idle-timeout=600 0 2
------------------------------

Make sure that this is only one line, do not break into multiple lines.




This is now the time to make a system bootable. This will create a boot image
 located in folder "/efi", which is stored as the first partition in the boot
  drive, "nvme01p1".

------------------------------
# cd /etc/mkinitcpio.d
# cp ./linux.present linux.preset.bkp
# nvim ./linux.preset
------------------------------

This will create a backup of the auto-generated linux.preset file. Then,
 when editing the original linux.preset file, change the variables
  "default_image" and "fallback_image" to be uncommented, if any are, and
   change the "boot" directory in each file path value to "efi".

example:
- before: default_image="/boot/initramfs-linux.img"
- after:  default_image="/efi"/initramfs-linux.img""

Then, the image files need moved. In this case, to keep the original files if
 they are needed, they will simply be copied.

------------------------------
# cp /boot/* /efi/
# mkinitcpio -P
------------------------------

Runing "mkinitcpio -P" whould not produce any errors. All images should be
 successfully built.


Because the primary drive that Arch is running on is encrypted, changes will
 need to be made to inform the booting image to decrpt it. In this case, the
  decryption that I'll use is System-D Encrypt, called "sd-encrypt".

------------------------------
# nvim /etc/mkinitcpoi.conf
------------------------------

While in the text editor, a little more than half way down the text file will
 be a line that starts with "HOOKS"

The "sd-encrypt" hook will need to be added. From left-to-right, the hooks
 should be in the order of:
- base
- systemd
- autodetect
- microcode
- modconf
- kms
- keyboard
- keymap
- sd-vconsole
- block
- sd-encrypt
- filesystems
- fsck

This adds the System-D Encrypt hook, so the system on boot knows how to decrypt
 the LUKS drive before the operating system on the encrypted drive starts. But
  next, we need to tell the booting image what drive to decrypt while it is
   running.


Kernel parameters now need setup to create a name after the Linux filesystem
 partition is decrypted and needs set as the root of the operating system.

First, create a series of folders, and a file:

------------------------------
# mkdir -p /efi/loader/entries
# touch arch.conf
------------------------------

Then, open the file and add the following lines:

------------------------------
title Arch Linux (linux)
linux /vmlinuz-linux
initrd /intel-ucode.img
initrd /initramfs-linux.img
options rd.luks.name={UUID}=root root=/dev/mapper/root rw rhgb quiet
  rootfstype=btrfs acpi_enforce_resources=lax
------------------------------

Because I am using intel microcode firmware, I want this microcode to be
 available before booting the Arch operating system. This is why a second
  initrd is added for the intel microcode "intel-ucode.img". If this was
   and AMD system, the AMD microcode would need to be added. The microcode
    initialization must occur before the initramfs-linux image.

options should only have one line. Make sure to not add a second line under
 options.

In options, the UUID to add is the UUID of the LUKS partition that needs opened.
 It is not for the btrfs partition after it is opened.

The "sd-encrypt" hook should decrypt the primary drive, followed by the kernel
 parameters giving the unlocked partition the name "dd-root", then define the
  decrypted partition as the root of the Arch system.

Then, to apply the new changes, run the command again:

 ------------------------------
# mkinitcpio -P
------------------------------

This will produce an error when "sd-encrypt" is being setup, for Intel QAT_6XXX.
 This is for Intel "QuckAssist Technology" for Intel Xeon 6 processors. This
  system doesn't use a Xeon processor, so this can be ignored. 

The QAT_6XXX firmware is an accelerator for Intel Xeon CPUs to run cryptogrpahic
 work on a co-processor designed for this type of work.



A boot loader now needs setup. In my case, I'm using system-d boot. This is
 initialized by the command:

------------------------------
# bootctl install
------------------------------

Since Arch has system-d setup be default, this command is readily available.

An error will appear that files are open to the world. This has already been
 resolved when editing "fstab" to restrict access.




For the root account, a password should be set:

------------------------------
# passwd
------------------------------

Then, reboot the system and see if it boots.
